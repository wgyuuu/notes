# 主线
``` mermaid
graph TB
    s1[顺序文件] --> s2[哈希索引] --> s3[SSTable]
```



# 顺序文件

## 最简单的存储
写数据：
``` shell
echo '${id}:${value}' >> data.txt
```
读数据：
``` shell
grep ${id} data.txt | awk -F ':' '{print $2}'
```

## 优缺点
1. 顺序写入文件，对磁盘io友好；
   > 操作系统中文件有页缓存，所以顺序写入文件速度比较快；
   > sata磁盘不用多说；
   > 提升ssd数据写入效率；
   >> page：最小的数据写入单元；
   >> block：由多个page组成，最小的数据擦除单元；
   >> 数据写入方式：读取原有page数据写入到缓存中&更新，然后再写入到一个新的page中 & 将原page置为无效。这样做的目的是方式热数据的频繁读写导致一个区域寿命耗尽；
2. 查询要全表扫描；

# 哈希索引

## hash map

### Bitcask
&nbsp;&nbsp;&nbsp;&nbsp;
Bitcask就是使用了这种方式，有两种文件：数据文件和索引文件。数据文件是顺序写入的，大大增加了数据写入的吞吐量。Bitcask会将key和value的位置以hash map的方式存在内存中，索引文件就是为了快速恢复这个索引内存的。在查询的时候，会先通过索引内存查找值的文件位置，然后再通过index获取真正的数据。

&nbsp;&nbsp;&nbsp;&nbsp;
索引内存写入磁盘，不必要实时可以定时写入。每次刷入磁盘记录一下当前的id，重启时可以通过上次写磁盘的id追溯新数据更新内存（数据是顺序写入的回溯也比较方便）。

### Redis
1. sds使用的是dict，采用hash散列方式存储；
2. dict有两个dictEntry，是用来做rehash的。rehash是通过每次增删改查来逐步迁移数据的（go的map是每次增改时迁移一条数据）；

## zskiplist
![avatar](./file/zskiplist.jpg)
### 数据结构
```c
typedef struct zskiplistNode {
    sds ele;
    double score; // 值
    struct zskiplistNode *backward;
    struct zskiplistLevel {
        struct zskiplistNode *forward;
        unsigned long span; // 记录上一个当前等级的节点到该节点中间的0层节点数
    } level[]; // 跳表有多层，L层链接即L-1层也会被链接
} zskiplistNode;
```

### 插入数据流程图
```flow
s=start:开始
e=end:结束
o=operation:操作项

s-o-e
```


# SSTable
